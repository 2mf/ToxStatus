// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const getNodeByPublicKey = `-- name: GetNodeByPublicKey :many
SELECT n.id, n.created_at, n.last_seen_at, n.public_key, n.fqdn, n.motd, a.id, a.created_at, a.last_seen_at, a.last_ping_at, a.last_pong_at, a.node_id, a.net, a.ip, a.port, a.ptr
FROM node n
LEFT JOIN node_address a ON a.node_id = n.id
WHERE n.public_key = ?
`

type GetNodeByPublicKeyRow struct {
	Node        Node
	NodeAddress NodeAddress
}

func (q *Queries) GetNodeByPublicKey(ctx context.Context, publicKey *PublicKey) ([]*GetNodeByPublicKeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodeByPublicKey, publicKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNodeByPublicKeyRow
	for rows.Next() {
		var i GetNodeByPublicKeyRow
		if err := rows.Scan(
			&i.Node.ID,
			&i.Node.CreatedAt,
			&i.Node.LastSeenAt,
			&i.Node.PublicKey,
			&i.Node.Fqdn,
			&i.Node.Motd,
			&i.NodeAddress.ID,
			&i.NodeAddress.CreatedAt,
			&i.NodeAddress.LastSeenAt,
			&i.NodeAddress.LastPingAt,
			&i.NodeAddress.LastPongAt,
			&i.NodeAddress.NodeID,
			&i.NodeAddress.Net,
			&i.NodeAddress.Ip,
			&i.NodeAddress.Port,
			&i.NodeAddress.Ptr,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNodeAddress = `-- name: InsertNodeAddress :one
INSERT INTO node_address(node_id, net, ip, port, ptr)
VALUES(?, ?, ?, ?, ?)
RETURNING id, created_at, last_seen_at, last_ping_at, last_pong_at, node_id, net, ip, port, ptr
`

type InsertNodeAddressParams struct {
	NodeID int64
	Net    string
	Ip     string
	Port   int64
	Ptr    sql.NullString
}

func (q *Queries) InsertNodeAddress(ctx context.Context, arg *InsertNodeAddressParams) (*NodeAddress, error) {
	row := q.db.QueryRowContext(ctx, insertNodeAddress,
		arg.NodeID,
		arg.Net,
		arg.Ip,
		arg.Port,
		arg.Ptr,
	)
	var i NodeAddress
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastPingAt,
		&i.LastPongAt,
		&i.NodeID,
		&i.Net,
		&i.Ip,
		&i.Port,
		&i.Ptr,
	)
	return &i, err
}

const updateNodeAddress = `-- name: UpdateNodeAddress :one
UPDATE node_address
SET node_id = ?, net = ?, ip = ?, port = ?, ptr = ?
WHERE id = ?
RETURNING id, created_at, last_seen_at, last_ping_at, last_pong_at, node_id, net, ip, port, ptr
`

type UpdateNodeAddressParams struct {
	NodeID int64
	Net    string
	Ip     string
	Port   int64
	Ptr    sql.NullString
	ID     int64
}

func (q *Queries) UpdateNodeAddress(ctx context.Context, arg *UpdateNodeAddressParams) (*NodeAddress, error) {
	row := q.db.QueryRowContext(ctx, updateNodeAddress,
		arg.NodeID,
		arg.Net,
		arg.Ip,
		arg.Port,
		arg.Ptr,
		arg.ID,
	)
	var i NodeAddress
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.LastPingAt,
		&i.LastPongAt,
		&i.NodeID,
		&i.Net,
		&i.Ip,
		&i.Port,
		&i.Ptr,
	)
	return &i, err
}

const upsertNode = `-- name: UpsertNode :one
INSERT INTO node(public_key, fqdn, motd)
VALUES(?, ?, ?)
ON CONFLICT(public_key) DO UPDATE SET fqdn = EXCLUDED.fqdn, motd = EXCLUDED.motd
RETURNING id, created_at, last_seen_at, public_key, fqdn, motd
`

type UpsertNodeParams struct {
	PublicKey *PublicKey
	Fqdn      sql.NullString
	Motd      sql.NullString
}

func (q *Queries) UpsertNode(ctx context.Context, arg *UpsertNodeParams) (*Node, error) {
	row := q.db.QueryRowContext(ctx, upsertNode, arg.PublicKey, arg.Fqdn, arg.Motd)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.PublicKey,
		&i.Fqdn,
		&i.Motd,
	)
	return &i, err
}
